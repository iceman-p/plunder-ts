export enum Kind {
  APP = 1,
  NAT,
  FUN,
  THUNK,
}

export type Nat = bigint;

export type Fan =
  | { t: Kind.APP; f:Fan; x:Fan }
  | { t: Kind.NAT; v:Nat }
  | { t: Kind.FUN; n:Nat; a:Nat; b:Fan; x:(f : Fan[]) => Fan }
  | { t: Kind.THUNK; x:() => void }

export function mkApp(f:Fan, x:Fan) : Fan {
  return mkThunk(function () { return { t:Kind.APP, f:f, x:x }})
}

export function mkNat(v:Nat) : Fan { return { t:Kind.NAT, v:v } }

export function mkThunk(val : (() => Fan)) : Fan {
  let t : Fan = { t: Kind.THUNK, x: function () {} }
  t.x = function () {
    let v = val();
    Object.assign(t, v);
  }
  return t;
}

// Non-exported check to ensure a Fan is forced. This is not the "public"
// force() function that does full forcing, but a thing used to force the
// current top layer.
function whnf(f : Fan) {
  while (f.t == Kind.THUNK) {
    f.x();
  }
}

// -----------------------------------------------------------------------

export enum RunKind {
  LOG,
  CNS,
  REF,
  KAL,
  LET
}

// Intermediate form for the compiler.
//
export type Run =
  | { t: RunKind.LOG, l: string, r: Run }
  | { t: RunKind.CNS, c: Fan }
  | { t: RunKind.REF, r: number }
  | { t: RunKind.KAL, f: Run, x: Run }
  | { t: RunKind.LET, i: number, v: Run, f: Run }

export type Prog = { arity: number,
                     stkSz: number,
                     prgm: (args : Fan[]) => Fan }

// Given a raw fan value, build out an intermediate Run structure describing
// the steps to run, plus the maximum stack size that this needs.
//
// internal detail, exported for testing.
export function fanToRun(maxArg : number, val : Fan) : [number, Run] {
  whnf(val);

  if (val.t == Kind.NAT && val.v <= BigInt(maxArg)) {
    return [maxArg, {t: RunKind.REF, r: Number(val.v)}];
  }

  if (val.t == Kind.APP) {
    whnf(val.f);

    if (val.f.t == Kind.NAT) {
      // If the toplevel `val` is `(2 x)`:
      if (val.f.v == 2n) {
        return [maxArg, {t: RunKind.CNS, c: val.x }]
      }
    } else if (val.f.t == Kind.APP) {
      if (val.f.f.t == Kind.NAT) {
        // If the toplevel `val` is `(0 f x)`:
        if (val.f.f.v == 0n) {
          let [fMax, fRun] = fanToRun(maxArg, val.f.x);
          let [xMax, xRun] = fanToRun(maxArg, val.x);
          return [Math.max(fMax, xMax),
                  {t: RunKind.KAL, f:fRun, x:xRun}];
        }
        // If the toplevel `val` is `(1 v b)`:
        if (val.f.f.v == 1n) {
          let [vMax, vRun] = fanToRun(maxArg + 1, val.f.x);
          let [bMax, bRun] = fanToRun(maxArg + 1, val.x);
          return [Math.max(vMax, bMax),
                  { t: RunKind.LET, i: maxArg + 1, v:vRun, f:bRun }];
        }
      }
    }
  }

  return [maxArg, {t: RunKind.CNS, c: val }]
}

// Given the Run structure from `fanToRun`, translate the Run structure into
// autogenerated javascript to pass to the interpreter, which should hopefully
// JIT it for us if we call it enough.
//
export function compileRunToFunction(maxStk : number, r : Run)
: (args : Fan[]) => Fan
{
  let preamble = `
    let stk = [...rawargs];
    if (` + maxStk + ` > stk.length) {
      stk.concat(Array(` + maxStk + ` - rawargs.length));
    }
    `;

  // Constant values need to be passed into the function instead of being in
  // the text because they might be thunks and their evaluation should cause
  // them to be evaluated outside of this function. They could also be very
  // large values and textifying them could be very expensive.
  let constants : Fan[] = [];

  function walk(r : Run) : string {
    switch (r.t) {
      case RunKind.LOG:
        let escaped = JSON.stringify(r.l);
        return "console.log(" + escaped + ");\n" + walk(r.r);
      case RunKind.CNS:
        let idx = constants.length
        constants.push(r.c);
        return "return constants[" + idx + "];";
      case RunKind.REF:
        return "return stk[" + r.r + "];"
      case RunKind.KAL:
        return "return push((function(){\n" + walk(r.f) +
          "\n})(), (function(){\n" + walk(r.x) + "\n})());";
      case RunKind.LET:
        return "stk[" + r.i + "] = (function(){\n" + walk(r.v) +
          "\n})();\n" +
          walk(r.f);
    }
  }

  // We walk the tree to turn everything into a set of statements.
  let functext = preamble + walk(r);

  let fun = new Function("push", "constants", "rawargs", functext) as
  ((p : (h : Fan, t : Fan) => Fan, consts: Fan[], args: Fan[]) => Fan);

  return function(args: Fan[]) : Fan {
    return fun(push, constants, args);
  }
}

export function mkFun(name : bigint, arity : bigint, body : Fan) : Fan {
  let thunk : Fan = mkThunk(() => {
    let [stkSize, run] = fanToRun(Number(arity), body);
    let fun = compileRunToFunction(stkSize, run);
    return {t: Kind.FUN, n:name, a:arity, b: body, x: fun};
  });

  if (arity == 0n) {
    whnf(thunk);
    return (thunk as {t: Kind.FUN, x:(f : Fan[]) => Fan}).x([thunk]);
  } else {
    return thunk;
  }
}

// -----------------------------------------------------------------------

function arity(val : Fan) : Nat {
  whnf(val);

  switch (val.t) {
    case Kind.APP:
      return arity(val.f) - 1n;
    case Kind.NAT:
      switch (val.v) {
        case 0n: return 3n;
        case 1n: return 4n;
        case 2n: return 3n;
        default: return 1n;
      }
    case Kind.FUN:
      return val.a;
    case Kind.THUNK:
      throw "Impossible: arity didn't preevaluate thunk";
  }
}

function force(val : Fan) : Fan {
  whnf(val);

  if (val.t == Kind.APP) {
    force(val.f);
    force(val.x);
  }
  return val;
}

function valNat(val : Fan) : Nat {
  whnf(val);

  if (val.t == Kind.NAT) {
    return val.v;
  } else {
    return 0n;
  }
}

// -----------------------------------------------------------------------

//
// Javascript isn't a real language: it has no tail call optimization. So
// emulate one level of tail calling by using a while loop. `continue` is a
// tail call, `return` actually returns a result.
function pluneval(n : Fan, args : Fan[]) : Fan {
  while (1) {
    switch (n.t) {
      case Kind.APP:
        args = [n.x].concat(args);
        n = n.f;
        continue;
      case Kind.NAT: {
        let v = n.v;
        if (v == 0n && args.length == 3) {
          return mkFun(valNat(args[0]), valNat(args[1]), args[2]);
        } else if (v == 1n && args.length == 4) {
          let f : Fan, a : Fan, n : Fan, x : Fan;
          [f, a, n, x] = args;

          let nod = force(x);
          switch (nod.t) {
            case Kind.FUN:
              return push(push(push(f, mkNat(nod.n)), mkNat(nod.a)), nod.b);
            case Kind.APP:
              return push(push(a, nod.f), nod.x);
            case Kind.NAT:
              return push(n, x);
            case Kind.THUNK:
              throw "Impossible to have a thunk here.";
          }
        } else if (v == 2n && args.length == 3) {
          let z, p, x;
          [z, p, x] = args;
          let n = valNat(x);
          if (n == 0n) {
            return z;
          } else {
            // TODO: Inline to save stack frames.
            return push(p, mkNat(n - 1n));
          }
        } else if (v == 3n && args.length == 1) {
          return mkNat(valNat(args[0]) + 1n);
        } else {
          return mkNat(0n);
        }
      }
      case Kind.FUN:
        return n.x([n, ...args]);
      case Kind.THUNK:
        n.x();
        continue;
    }
  }

  throw "Impossible end of interpreter";
}


// Entry point.
//
// (%%) :: Fan -> Fan -> Fan
export function push(head : Fan, tail : Fan) : Fan {
  if (arity(head) == 1n) {
    return pluneval(head, [tail])
  } else {
    return mkApp(head, tail);
  }
}

// Local Variables:
// typescript-indent-level: 2
// End:
